<html>

<head>
    <title>Path Drawing Tool</title>
    <meta charset="utf-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Load third-party libraries -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.5/lib/p5.js" type="text/javascript"></script>
    <!-- Load our application code -->
    <script>
        let currentPath = [];
        let allPaths = [];
        let singlePoints = [];
        let limitLenght = 2000;

        let mouseStart = false;
        let mouseEnd = false;

        let dotLimit = 40;
        let pathLimit = 30;

        let isCanvasTouch = false;

        function setup() {
            const canvas = createCanvas(500, 500).parent('canvas-container');
            textSize(12);
            textAlign(LEFT, CENTER);
            noFill();
            strokeWeight(2);

            // é˜²æ­¢æ‰‹æŒ‡æ‹–æ‹‰æ™‚ï¼Œè¦–çª—å·¦å³æ™ƒå‹•
            canvas.elt.addEventListener('touchmove', function (e) {
                e.preventDefault();
            }, { passive: false });
            document.addEventListener("touchmove", preventBehavior, {
                passive: false
            });
            // ä¸å†è‡ªå‹•èª¿æ•´ canvas å°ºå¯¸
            // windowResized();

            // document.addEventListener('touchstart', function (e) {
            //     const canvas = document.querySelector('#canvas-container canvas');
            //     if (!canvas) return;
            //     const rect = canvas.getBoundingClientRect();
            //     const touch = e.touches[0];
            //     if (!touch) return;
            //     // åˆ¤æ–­è§¦æ‘¸èµ·ç‚¹æ˜¯å¦åœ¨canvaså†…
            //     if (
            //         touch.clientX >= rect.left && touch.clientX <= rect.right &&
            //         touch.clientY >= rect.top && touch.clientY <= rect.bottom
            //     ) {
            //         isCanvasTouch = true;
            //     } else {
            //         isCanvasTouch = false;
            //     }
            // });
            // document.addEventListener('touchmove', function (e) {
            //     if (isCanvasTouch) {
            //         e.preventDefault();
            //     }
            // }, { passive: false });
            // document.addEventListener('touchend', function () {
            //     isCanvasTouch = false;
            // });
        }


        function preventBehavior(e) {
            e.preventDefault();
        }
        function draw() {
            background(230);

            // ç•«æ‰€æœ‰è·¯å¾‘èˆ‡æ¨™è¨»
            for (let i = 0; i < allPaths.length; i++) {
                drawPathWithLabels(allPaths[i], i);
            }

            // ç•«ç¨ç«‹é»
            for (let i = 0; i < singlePoints.length; i++) {
                let pt = singlePoints[i];
                fill(0);
                ellipse(pt.x, pt.y, 8, 8);
                noStroke();
                fill(255, 0, 0);
                text(`Dot ${i + 1}`, pt.x + 5, pt.y);
                stroke(0);
            }

            // ç•«ç›®å‰ç­†ç•«çš„é»
            if (mouseIsPressed) {
                currentPath.push(createVector(mouseX, mouseY));
                drawRawPoints(currentPath);
            }
        }

        function drawRawPoints(path) {
            if (path.length === 0) return;
            // ç•«èµ·é»
            fill(255, 0, 0);
            noStroke();
            ellipse(path[0].x, path[0].y, 12, 12);

            // ç•«èµ·é»åˆ°æ»‘é¼ çš„ç·š
            stroke(255, 0, 0);
            noFill();
            if (mouseIsPressed) {
                line(path[0].x, path[0].y, mouseX, mouseY);
            }
        }

        function drawPathWithLabels(path, pathIndex) {
            stroke(0);
            noFill();
            beginShape();
            for (let i = 0; i < path.length; i++) {
                let pt = path[i];
                vertex(pt.x, pt.y);
            }
            endShape();

            for (let i = 0; i < path.length; i++) {
                let pt = path[i];
                fill(0);
                ellipse(pt.x, pt.y, 6, 6);
                noStroke();
                fill(50, 100, 200);
                text(`P${pathIndex + 1}-${i}`, pt.x + 5, pt.y);
                stroke(0);
            }

            let labelPos = path[0];
            noStroke();
            fill(255, 0, 0);
            text(`Path ${pathIndex + 1}`, labelPos.x + 10, labelPos.y - 15);
            stroke(0);
        }

        function mouseReleased() {
            if (currentPath.length > 1) {
                let totalLength = calculatePathLength(currentPath);
                let totalAngle = calculateTotalAngle(currentPath);

                if (totalLength < 20) {
                    // ç¡®ä¿ç‚¹åœ¨ç”»å¸ƒèŒƒå›´å†…(500x500)
                    let pt = currentPath[0].copy();
                    if (pt.x >= 0 && pt.x <= 500 && pt.y >= 0 && pt.y <= 500) {
                        singlePoints.push(pt);
                        // æ–°å¢ï¼šé™åˆ¶ singlePoints æœ€å¤š 40 ä¸ª
                        if (singlePoints.length > dotLimit) {
                            singlePoints.shift();
                        }
                        console.log(`æ·»åŠ ç‹¬ç«‹ç‚¹: (${pt.x.toFixed(1)}, ${pt.y.toFixed(1)})`);
                    } else {
                        console.log(`å¿½ç•¥ç”»å¸ƒèŒƒå›´å¤–çš„ç‚¹: (${pt.x.toFixed(1)}, ${pt.y.toFixed(1)})`);
                    }
                } else {
                    let minPoints = 2;

                    // ğŸ”§ å‹•æ…‹é™åˆ¶ maxPointsï¼šçŸ­ç·šæœ€å¤šåªåˆ† 4~6 é»
                    let dynamicMax = floor(map(totalLength, 20, 500, 4, 12));
                    let maxPoints = constrain(dynamicMax, minPoints, 12);

                    let lengthFactor = map(totalLength, 20, 500, 0, 1);
                    let angleFactor = map(totalAngle, 0, 720, 0, 1);
                    let blend = lengthFactor * 0.5 + angleFactor * 0.5;

                    let mappedCount = round(map(blend, 0, 1, minPoints, maxPoints));
                    let pointCount = constrain(mappedCount, minPoints, maxPoints);

                    let simplified = resamplePath(currentPath, pointCount);
                    allPaths.push(simplified);
                    // æ–°å¢ï¼šé™åˆ¶ allPaths æœ€å¤š 30 æ¡
                    if (allPaths.length > pathLimit) {
                        allPaths.shift();
                    }
                }
            }
            currentPath = [];
        }

        function calculatePathLength(path) {
            let total = 0;
            for (let i = 1; i < path.length; i++) {
                total += p5.Vector.dist(path[i], path[i - 1]);
            }
            return total;
        }

        function calculateTotalAngle(path) {
            let totalAngle = 0;
            for (let i = 1; i < path.length - 1; i++) {
                let v1 = p5.Vector.sub(path[i], path[i - 1]);
                let v2 = p5.Vector.sub(path[i + 1], path[i]);

                if (v1.mag() === 0 || v2.mag() === 0) continue; // å¿½ç•¥ç„¡æ•ˆå‘é‡

                let angle = degrees(v1.angleBetween(v2));
                if (!isNaN(angle)) {
                    totalAngle += abs(angle);
                }
            }
            return totalAngle;
        }

        function resamplePath(path, count) {
            let totalLength = 0;
            let distances = [];

            for (let i = 1; i < path.length; i++) {
                let d = p5.Vector.dist(path[i], path[i - 1]);
                distances.push(d);
                totalLength += d;
            }

            // âœ… åŠ å…¥ï¼šå¦‚æœæ¥è¿‘ç›´ç·šï¼Œå°±ç›´æ¥å›å‚³èµ·é»èˆ‡çµ‚é»
            if (isAlmostStraight(path)) {
                // console.log("æ¥è¿‘ç›´ç·š");
                return [path[0].copy(), path[path.length - 1].copy()];
            }

            let interval = totalLength / (count - 1);
            let newPath = [];
            let targetDist = 0;
            let accumulated = 0;

            for (let i = 1; i < path.length; i++) {
                let segStart = path[i - 1];
                let segEnd = path[i];
                let d = distances[i - 1];

                if (accumulated + d >= targetDist) {
                    let t = (targetDist - accumulated) / d;
                    let newPoint = p5.Vector.lerp(segStart, segEnd, t);
                    let xx = Number(newPoint.x.toFixed(2));
                    let yy = Number(newPoint.y.toFixed(2));
                    newPoint.x = map(xx, 0, 500, 0, 500);
                    newPoint.y = map(yy, 0, 500, 0, 500);
                    newPath.push(newPoint);
                    targetDist += interval;
                    i--;
                } else {
                    accumulated += d;
                }

                if (newPath.length === count) break;
            }

            if (newPath.length < count) {
                newPath.push(path[path.length - 1].copy());
            }

            return newPath;
        }

        function isAlmostStraight(path) {
            let totalLength = calculatePathLength(path);
            if (totalLength < limitLenght) return true; // â­ é•·åº¦çŸ­å°±ç›´æ¥è¦–ç‚ºç›´ç·š

            let totalAngle = calculateTotalAngle(path);
            return totalAngle < 20 && path.length >= 3;
        }

        function keyPressed() {
            if (keyCode === ENTER) {
                let hashPart;
                const result = generateURLFromData();
                if (result && result.url) {
                    const linkElement = document.getElementById('generated-link');
                    hashPart = result.url.substring(result.url.indexOf('#data_'));
                    linkElement.innerText = hashPart;
                    linkElement.style.display = 'block';
                    document.getElementById('copy-button').style.display = 'block';
                    const seeButton = document.getElementById('see-button');
                    seeButton.style.display = 'inline-block';
                    seeButton.onclick = function () {
                        // æ¯æ¬¡éƒ½é‡æ–°ç”¢ç”Ÿæ–°çš„ seed èˆ‡ç¶²å€
                        const newResult = generateURLFromData();
                        if (newResult && newResult.url) {
                            const fixedUrl = newResult.url
                              .replace(/%3D/gi, '=')
                              .replace(/%2F/gi, '/')
                              .replace(/%2B/gi, '+');
                            window.open(fixedUrl, '_blank');
                        }
                    };
                }

            }
        }

        // ç”¢ç”Ÿ7ä½äº‚æ•¸è‹±æ•¸å­—
        function generateSeed(len = 7) {

            let seed = '';

            seed = Math.floor(Math.random() * 6000000 + 3000000);

            return seed;
        }

        function generateURLFromData() {
            // 1. ä½¿ç”¨ç›¸å¯¹åæ ‡æ ¼å¼å‹ç¼©æ•°æ®
            let compressedPaths = allPaths.map(compressPath);
            let compressedDots = [];

            // åªæœ‰å½“æœ‰ç‹¬ç«‹ç‚¹æ—¶æ‰å‹ç¼©ï¼Œå¹¶ä¸”è¿‡æ»¤æ‰ç”»å¸ƒèŒƒå›´å¤–çš„ç‚¹
            if (singlePoints && singlePoints.length > 0) {
                // è¿‡æ»¤å‡ºç”»å¸ƒèŒƒå›´å†…çš„ç‚¹ï¼ˆç”»å¸ƒå¤§å°ä¸º500x500ï¼‰
                const validSinglePoints = singlePoints.filter(p =>
                    p.x >= 0 && p.x <= width && p.y >= 0 && p.y <= height
                );

                if (validSinglePoints.length < singlePoints.length) {
                    console.log(`è¿‡æ»¤æ‰${singlePoints.length - validSinglePoints.length}ä¸ªç”»å¸ƒèŒƒå›´å¤–çš„ç‚¹`);
                }

                if (validSinglePoints.length > 0) {
                    compressedDots = validSinglePoints.map(p => [
                        Number(p.x.toFixed(1)),
                        Number(p.y.toFixed(1))
                    ]);
                    console.log(`å‹ç¼©äº†${compressedDots.length}ä¸ªç‹¬ç«‹ç‚¹`);
                } else {
                    console.log('æ²¡æœ‰æœ‰æ•ˆçš„ç‹¬ç«‹ç‚¹éœ€è¦å‹ç¼©');
                }
            } else {
                console.log('æ²¡æœ‰ç‹¬ç«‹ç‚¹éœ€è¦å‹ç¼©');
            }

            let data = {
                p: compressedPaths,
                d: compressedDots
            };

            try {
                // å‡†å¤‡ä¸åŒçš„å‹ç¼©æ–¹æ³•ï¼Œå¹¶é€‰æ‹©æœ€é«˜æ•ˆçš„ç»“æœ
                const jsonStr = JSON.stringify(data);

                // æ ‡å‡† base64 ç¼–ç 
                const base64Str = btoa(jsonStr);
                const base64Url = encodeURIComponent(base64Str);

                // ä½¿ç”¨è‡ªå®šä¹‰äºŒè¿›åˆ¶æ ¼å¼å‹ç¼©
                const binaryStr = compressToBinary(data);
                const binaryUrl = encodeURIComponent(binaryStr);

                // é€‰æ‹©æœ€çŸ­çš„å‹ç¼©æ–¹æ³•
                let shortestStr = base64Url;
                let compressionMethod = "base64";

                if (binaryUrl.length < shortestStr.length) {
                    shortestStr = binaryUrl;
                    compressionMethod = "binary";
                }

                // ç”¢ç”Ÿäº‚æ•¸ç¨®å­
                const seed = generateSeed(7);

                // æ§‹å»º hash éƒ¨åˆ†ï¼Œæ ¼å¼ç‚º #data_xxx&seed_xxxxxxx
                const hashPart = "#data_" + shortestStr + "&seed_" + seed;

                // æ ¹æ“šæœ¬åœ°æˆ–é ç«¯æ±ºå®š baseUrl
                let baseUrl;
                if (window.location.hostname === "127.0.0.1" || window.location.hostname === "localhost") {
                    baseUrl = window.location.origin + "/";
                } else if (window.location.hostname === "polypaths.up.railway.app") {
                    baseUrl = "https://polypaths.up.railway.app/";
                } else {
                    baseUrl = "https://aluanwang.com/Polypaths/";
                }
                const completeURL = baseUrl + hashPart;

                const totalLength = completeURL.length;
                const charCount = completeURL.split('').length;

                console.log(`ğŸ”— ç¶²å€é•·åº¦ï¼š${totalLength} å­—å…ƒ (${charCount} å€‹å­—ç¬¦)`);
                console.log(`ğŸ“Š å£“ç¸®æ–¹å¼ï¼š${compressionMethod}`);
                console.log(`ğŸ“Š å£“ç¸®å‰JSONé•·åº¦ï¼š${jsonStr.length} å­—å…ƒ`);
                console.log(`ğŸ“Š å£“ç¸®å¾ŒURLåƒæ•¸é•·åº¦ï¼š${shortestStr.length} å­—å…ƒ`);
                console.log(`ğŸ“Š å£“ç¸®æ¯”ä¾‹ï¼š${Math.round((1 - shortestStr.length / jsonStr.length) * 100)}%`);

                if (totalLength > 2000) {
                    console.warn("âš ï¸ é€™å€‹ç¶²å€å¤ªé•·äº†ï¼æœ‰äº›ç€è¦½å™¨å¯èƒ½æœƒçˆ†ç‚¸ã€‚");
                    offerAlternatives();
                } else if (totalLength > 1500) {
                    console.warn("âš ï¸ ç¶²å€å·²åé•·ï¼Œè«‹ç¯€åˆ¶ä½ é‚£æ”¾é£›è‡ªæˆ‘çš„ç¹ªåœ–ç¿’æ…£ã€‚");
                } else {
                    // console.log("âœ… å®‰å…¨ç¯„åœå…§ï¼Œæ­å–œä½ æ²’æœ‰ç•«æ»¿ä¸€æ•´æœ¬ã€‚");
                }

                console.log("ğŸ”— è«‹è¤‡è£½ä»¥ä¸‹ç¶²å€ï¼š\n" + completeURL);

                // === æ–°å¢ï¼šç”¢ç”Ÿè³‡æ–™å¾Œé¡¯ç¤ºæŒ‰éˆ• ===
                const linkElement = document.getElementById('generated-link');
                linkElement.innerText = completeURL
                  .replace(/%3D/gi, '=')
                  .replace(/%2F/gi, '/')
                  .replace(/%2B/gi, '+');
                linkElement.style.display = 'block';

                const copyButton = document.getElementById('copy-button');
                if (copyButton) copyButton.style.display = 'block';

                const seeButton = document.getElementById('see-button');
                const pushButton = document.getElementById('push-button');
                const host = window.location.hostname;
                if (seeButton) seeButton.style.display = 'none';
                if (pushButton) pushButton.style.display = 'none';
                if (host === 'localhost' || host === '127.0.0.1' || host.includes('aluanwang.com')) {
                    if (seeButton) {
                        seeButton.style.display = 'inline-block';
                        seeButton.onclick = function () {
                            // åªç”¢ç”Ÿä¸€æ¬¡æ–° seed èˆ‡ç¶²å€ï¼Œç›´æ¥é–‹æ–°åˆ†é 
                            const newResult = generateURLFromData();
                            if (newResult && newResult.url) {
                                const fixedUrl = newResult.url
                                  .replace(/%3D/gi, '=')
                                  .replace(/%2F/gi, '/')
                                  .replace(/%2B/gi, '+');
                                window.open(fixedUrl, '_blank');
                            }
                        };
                    }
                } else if (host === 'polypaths.up.railway.app') {
                    if (pushButton) {
                        pushButton.style.display = 'inline-block';
                        pushButton.onclick = function () {
                            const newResult = generateURLFromData();
                            if (newResult && newResult.url) {
                                const hash = newResult.url.split('#')[1]
                                    ? '#' + newResult.url.split('#')[1]
                                        .replace(/%3D/gi, '=')
                                        .replace(/%2F/gi, '/')
                                        .replace(/%2B/gi, '+')
                                    : '';
                                fetch('https://postbotanybackend.up.railway.app/trigger-new-url', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ hash: hash })
                                })
                                    .then(res => {
                                        if (!res.ok) throw new Error(res.statusText);
                                        pushButton.textContent = 'success';
                                        pushButton.classList.add('success');
                                        pushButton.classList.remove('failed');
                                        setTimeout(() => {
                                            pushButton.textContent = 'Push';
                                            pushButton.classList.remove('success');
                                            pushButton.classList.remove('failed');
                                        }, 3000);
                                    })
                                    .catch(err => {
                                        pushButton.textContent = 'failed';
                                        pushButton.classList.add('failed');
                                        pushButton.classList.remove('success');
                                        setTimeout(() => {
                                            pushButton.textContent = 'Push';
                                            pushButton.classList.remove('failed');
                                            pushButton.classList.remove('success');
                                        }, 3000);
                                    });
                            }
                        };
                    }
                }
                // === END ===

                // è¿”å›å®Œæ•´çµæ§‹ï¼Œä¾› see-button ä½¿ç”¨
                return { url: completeURL, hash: hashPart, baseUrl, seed };

            } catch (err) {
       
                console.error(err);
                return null;
            }
        }

        // å‹ç¼©è·¯å¾„æ•°æ®ï¼šä½¿ç”¨ç›¸å¯¹åæ ‡å’Œå‡å°‘ç²¾åº¦
        function compressPath(path) {
            if (path.length < 2) return [];

            // å°†ç¬¬ä¸€ä¸ªç‚¹ä½œä¸ºåŸºå‡†ç‚¹ï¼Œä½¿ç”¨0ä½å°æ•°ç²¾åº¦ï¼ˆå››èˆäº”å…¥å–æ•´ï¼‰
            let startX = Math.round(path[0].x);
            let startY = Math.round(path[0].y);
            let result = [[startX, startY]];
            console.log(`å‹ç¼©è·¯å¾„: ç¬¬ä¸€ç‚¹åæ ‡ (${path[0].x}, ${path[0].y}) => (${result[0][0]}, ${result[0][1]})`);

            // æ£€æŸ¥æ˜¯å¦æ˜¯é•¿ç›´çº¿ï¼ˆè¶…è¿‡127åƒç´ ï¼‰
            if (path.length === 2) {
                const endX = Math.round(path[1].x);
                const endY = Math.round(path[1].y);
                const dx = endX - startX;
                const dy = endY - startY;

                // å¦‚æœæ˜¯é•¿ç›´çº¿ï¼Œéœ€è¦å°†å…¶åˆ†æ®µå¤„ç†
                if (Math.abs(dx) > 127 || Math.abs(dy) > 127) {
                    console.log(`æ£€æµ‹åˆ°é•¿ç›´çº¿: èµ·ç‚¹(${startX}, ${startY})ï¼Œç»ˆç‚¹(${endX}, ${endY})ï¼Œåç§»(${dx}, ${dy})`);

                    // è®¡ç®—åˆ†æ®µæ•°é‡
                    const segments = Math.max(
                        Math.ceil(Math.abs(dx) / 120), // ç”¨120è€Œä¸æ˜¯127ï¼Œç•™ä¸€äº›ä½™é‡
                        Math.ceil(Math.abs(dy) / 120)
                    );

                    console.log(`å°†ç›´çº¿åˆ†ä¸º${segments}æ®µ`);

                    // å‡åŒ€åˆ†å¸ƒç‚¹
                    for (let i = 1; i <= segments; i++) {
                        const t = i / segments;
                        const midX = Math.round(startX + dx * t);
                        const midY = Math.round(startY + dy * t);

                        // æ·»åŠ ç›¸å¯¹äºå‰ä¸€ç‚¹çš„åæ ‡
                        const prevX = i === 1 ? startX : Math.round(startX + dx * ((i - 1) / segments));
                        const prevY = i === 1 ? startY : Math.round(startY + dy * ((i - 1) / segments));

                        const segDx = midX - prevX;
                        const segDy = midY - prevY;

                        result.push([segDx, segDy]);
                        console.log(`åˆ†æ®µ${i}: æ·»åŠ ç‚¹(${midX}, ${midY})ï¼Œç›¸å¯¹åç§»(${segDx}, ${segDy})`);
                    }

                    return result;
                }
            }

            // å¸¸è§„å¤„ç†ï¼šåç»­ç‚¹ä½¿ç”¨ä¸å‰ä¸€ç‚¹çš„ç›¸å¯¹ä½ç½®
            for (let i = 1; i < path.length; i++) {
                let dx = Math.round(path[i].x - path[i - 1].x);
                let dy = Math.round(path[i].y - path[i - 1].y);

                // é™åˆ¶åœ¨æœ‰æ•ˆèŒƒå›´å†…
                if (dx < -127) dx = -127;
                if (dx > 127) dx = 127;
                if (dy < -127) dy = -127;
                if (dy > 127) dy = 127;

                result.push([dx, dy]);
                console.log(`ç¬¬${i + 1}ç‚¹: åŸåæ ‡(${path[i].x}, ${path[i].y}) => ç›¸å¯¹åç§»(${dx}, ${dy})`);
            }

            return result;
        }

        // ä½¿ç”¨è‡ªå®šä¹‰äºŒè¿›åˆ¶æ ¼å¼å‹ç¼©æ•°æ®
        function compressToBinary(data) {
            // é¦–å…ˆå°†æ•°æ®ç»“æ„ç®€åŒ–ä¸ºæ›´ç´§å‡‘çš„æ ¼å¼
            let result = '';

            // æ·»åŠ è·¯å¾„æ•°é‡ (æœ€å¤§255æ¡è·¯å¾„)
            result += String.fromCharCode(data.p.length);
            console.log(`ç¼–ç è·¯å¾„æ•°é‡: ${data.p.length}`);

            // æ·»åŠ æ¯æ¡è·¯å¾„
            for (let path of data.p) {
                // è·¯å¾„ç‚¹æ•°é‡ (æœ€å¤§255ä¸ªç‚¹)
                result += String.fromCharCode(path.length);
                console.log(`ç¼–ç è·¯å¾„ç‚¹æ•°é‡: ${path.length}`);

                for (let i = 0; i < path.length; i++) {
                    const point = path[i];
                    if (i === 0) {
                        // é¦–ä¸ªç‚¹ä½¿ç”¨ç»å¯¹åæ ‡ï¼Œé™¤ä»¥2å‹ç¼©èŒƒå›´ (å‡è®¾ç”»å¸ƒå¤§å°500x500)
                        // ä½¿ç”¨8ä½æ•´æ•°è¡¨ç¤ºä½ç½® (0-255)ï¼Œå¯ä»¥è¡¨ç¤ºç”»å¸ƒçš„0-510ä½ç½®
                        const x = Math.min(255, Math.max(0, Math.round(point[0] / 2)));
                        const y = Math.min(255, Math.max(0, Math.round(point[1] / 2)));
                        result += String.fromCharCode(x) + String.fromCharCode(y);

                        // è°ƒè¯•ä¿¡æ¯ï¼šåŸå§‹å€¼å’Œå‹ç¼©å€¼
                        console.log(`äºŒè¿›åˆ¶å‹ç¼©ï¼šåŸå§‹åæ ‡(${point[0]}, ${point[1]}) => ç¼–ç å€¼(${x}, ${y}) => è§£ç å(${x * 2}, ${y * 2})`);
                    } else {
                        // åç»­ç‚¹ä½¿ç”¨ç›¸å¯¹åæ ‡
                        // ç¡®ä¿ç›¸å¯¹åæ ‡åœ¨-127åˆ°127èŒƒå›´å†…
                        let dx = point[0];
                        let dy = point[1];

                        // è¿™é‡Œä¸å†éœ€è¦è¿›ä¸€æ­¥é™åˆ¶ï¼Œå› ä¸ºcompressPathå·²ç»ç¡®ä¿å€¼åœ¨-127åˆ°127èŒƒå›´å†…

                        // è½¬æ¢ä¸ºæ— ç¬¦å·å€¼(0-255)
                        const dxEncoded = (dx + 128) & 0xFF;
                        const dyEncoded = (dy + 128) & 0xFF;

                        result += String.fromCharCode(dxEncoded) + String.fromCharCode(dyEncoded);

                        // è°ƒè¯•ä¿¡æ¯
                        console.log(`ç›¸å¯¹åæ ‡: (${point[0]}, ${point[1]}) => ç¼–ç å€¼(${dxEncoded}, ${dyEncoded}) => è§£ç å(${dxEncoded - 128}, ${dyEncoded - 128})`);
                    }
                }
            }

            // æ·»åŠ ç‹¬ç«‹ç‚¹æ•°é‡
            const dotCount = data.d.length;
            result += String.fromCharCode(dotCount);
            console.log(`ç¼–ç ç‹¬ç«‹ç‚¹æ•°é‡: ${dotCount}`);

            // åªæœ‰åœ¨æœ‰ç‹¬ç«‹ç‚¹æ—¶æ‰æ·»åŠ ç‚¹æ•°æ®
            if (dotCount > 0) {
                console.log(`å¼€å§‹ç¼–ç ${dotCount}ä¸ªç‹¬ç«‹ç‚¹`);
                // æ·»åŠ æ¯ä¸ªç‹¬ç«‹ç‚¹
                for (let dot of data.d) {
                    // ç‚¹åæ ‡ï¼ŒåŒæ ·é™¤ä»¥2å‹ç¼©èŒƒå›´
                    const x = Math.min(255, Math.max(0, Math.round(dot[0] / 2)));
                    const y = Math.min(255, Math.max(0, Math.round(dot[1] / 2)));
                    result += String.fromCharCode(x) + String.fromCharCode(y);
                    console.log(`ç¼–ç ç‹¬ç«‹ç‚¹: åŸåæ ‡(${dot[0]}, ${dot[1]}) => ç¼–ç å€¼(${x}, ${y})`);
                }
            }

            // è¿”å› base64 ç¼–ç çš„ç»“æœ
            console.log(`äºŒè¿›åˆ¶å‹ç¼©æ€»é•¿åº¦: ${result.length} å­—ç¬¦`);
            return btoa(result);
        }

        // æä¾›æ›¿ä»£æ–¹æ¡ˆ
        function offerAlternatives() {
            console.log("ğŸ”„ æ‚¨å¯ä»¥ï¼š");
            console.log("1. å‡å°‘è·¯å¾„æ•°é‡æˆ–è·¯å¾„ç‚¹æ•°é‡");
            console.log("2. å°è¯•ä½¿ç”¨æ›´ç®€å•çš„ç»˜å›¾");
            console.log("3. ä½¿ç”¨äº‘ç«¯å­˜å‚¨ (å¦‚ Imgurã€Gist ç­‰)");
        }

        // è¾…åŠ©å‡½æ•°ï¼šå°† Uint8Array è½¬æ¢ä¸º base64
        function arrayToBase64(array) {
            let binary = '';
            const len = array.length;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(array[i]);
            }
            return btoa(binary);
        }

        function touchStarted() {
            // åªåœ¨æ²’æœ‰é»æ™‚æ‰é–‹å§‹æ–°ç·š
            if (currentPath.length === 0) {
                currentPath.push(createVector(mouseX, mouseY));
            }
            return true; // å…è¨±äº‹ä»¶å†’æ³¡ï¼Œè®“ä¸‹æ–¹æŒ‰éˆ•å¯é»æ“Š
        }

        function touchEnded() {
            // ç›´æ¥å‘¼å« mouseReleased çš„å…§å®¹
            if (currentPath.length > 1) {
                let totalLength = calculatePathLength(currentPath);
                let totalAngle = calculateTotalAngle(currentPath);

                if (totalLength < 20) {
                    // ç¢ºä¿é»åœ¨ç•«å¸ƒç¯„åœå…§(500x500)
                    let pt = currentPath[0].copy();
                    if (pt.x >= 0 && pt.x <= 500 && pt.y >= 0 && pt.y <= 500) {
                        singlePoints.push(pt);
                        // æ–°å¢ï¼šé™åˆ¶ singlePoints æœ€å¤š 40 å€‹
                        if (singlePoints.length > 40) {
                            singlePoints.shift();
                        }
                        console.log(`æ·»åŠ ç¨ç«‹é»: (${pt.x.toFixed(1)}, ${pt.y.toFixed(1)})`);
                    } else {
                        console.log(`å¿½ç•¥ç•«å¸ƒç¯„åœå¤–çš„é»: (${pt.x.toFixed(1)}, ${pt.y.toFixed(1)})`);
                    }
                } else {
                    let minPoints = 2;
                    let dynamicMax = floor(map(totalLength, 20, 500, 4, 12));
                    let maxPoints = constrain(dynamicMax, minPoints, 12);
                    let lengthFactor = map(totalLength, 20, 500, 0, 1);
                    let angleFactor = map(totalAngle, 0, 720, 0, 1);
                    let blend = lengthFactor * 0.5 + angleFactor * 0.5;
                    let mappedCount = round(map(blend, 0, 1, minPoints, maxPoints));
                    let pointCount = constrain(mappedCount, minPoints, maxPoints);
                    let simplified = resamplePath(currentPath, pointCount);
                    allPaths.push(simplified);
                    // æ–°å¢ï¼šé™åˆ¶ allPaths æœ€å¤š 30 æ¢
                    if (allPaths.length > 30) {
                        allPaths.shift();
                    }
                }
            }
            currentPath = [];
            return true; // å…è¨±äº‹ä»¶å†’æ³¡ï¼Œè®“ä¸‹æ–¹æŒ‰éˆ•å¯é»æ“Š
        }

    </script>

    <style>
        :root {
            --primary-color: #313131;
            --success-color: #E25200;
            --failed-color: #53D060;
            --background-color: #313131;
            --container-bg: #212121;
            --text-color: #000000;
            --text-color2: #ffffff;
            --border-color: #000000;
            --shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
            --border-radius: 10px;
            --spacing: 20px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            padding: 25px;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1;
        }

        .container {
            width: 100%;
            max-width: calc(100vw - 100px);
            background-color: transparent;
            padding: calc(var(--spacing) * 1.1);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: var(--spacing);
            background-image: linear-gradient(rgba(255, 140, 0, 0.4), rgba(255, 255, 255, 0.6)), url('banner.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            max-width: 500px;
            max-height: 500px;
        
        }

        h2 {
            color: var(--text-color);
            margin-bottom: calc(var(--spacing) / 4);
            text-align: center;
            font-size: 1.2rem;
        }

        #canvas-container {
            width: 100%;
            max-width: calc(100vw - 100px);
            aspect-ratio: 1 / 1;
            margin: 0 auto;
            margin-bottom: 30px;
            max-width: 500px;
            max-height: 500px;
            border-radius: 10px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
        }

        canvas {
            border: 1px solid var(--border-color);
            border-radius: 10px;
            margin-bottom: var(--spacing);
            width: 100% !important;
            height: auto !important;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 1 / 1;
            object-fit: contain;
            display: block;
            max-width: 500px !important;
            max-height: 500px !important;
        }

        .help-text {
            margin: var(--spacing) 0;
            color: #000000;
            font-size: 0.8rem;
            text-align: center;
            max-width: 500px;
            line-height: 1.2;
            margin-left: auto;
            margin-right: auto;
        }

        .button-container {
            margin: var(--spacing) 0;
            display: flex;
            gap: calc(var(--spacing) / 2);
            justify-content: center;
            flex-wrap: wrap;
        }

        .button {
            padding: 8px 15px;
            background-color: var(--primary-color) !important;
            color: white;
            border: none;
            border-radius: calc(var(--border-radius) / 2);
            cursor: pointer;
            font-size: 0.6rem;
            font-weight: 500;
            transition: all 0.3s ease;
            min-width: 120px;
            text-align: center;
        }

        .button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .button:active {
            transform: translateY(0);
        }

        .button.success {
            background-color: var(--success-color) !important;
            color: #fff !important;
        }

        .button.failed {
            background-color: var(--failed-color) !important;
            color: #fff !important;
        }

        .link-container {
            margin-top: calc(var(--spacing) / 4);
            width: 100%;
        }

        .generated-link {
            width: 100%;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: calc(var(--border-radius) / 2);
            background-color: #535353;
            font-size: 0.4rem;
            color: var(--text-color2);
            word-break: break-all;
            display: none;
            margin-top: calc(var(--spacing) / 4);
            font-family: monospace;
        }

        .copy-see-group {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: calc(var(--spacing) / 4);
            justify-content: center;
        }

        .copy-button {
            background-color: var(--success-color);
            margin-top: calc(var(--spacing) / 4);
            display: none;
        }

        @media (max-width: 600px) {
            :root {
                --spacing: 15px;
            }

            body {
                padding: 30px;
            }

            .container {
                max-width: calc(100vw - 100px);
            }

            #canvas-container {
                max-width: calc(100vw - 100px);
            }

            .button {
                width: 100%;
                min-width: unset;
            }

            .button-container {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>
    <div class="container">
        <h2>Polypaths Drawing Mode</h3>

        <div class="button-container">
            <button class="button" onclick="generateURLFromData()">Generate Data</button>
            <button class="button" onclick="clearCanvas()">Clear</button>
            <!-- <button class="button" id="save-image">Save paths</button> -->
        </div>

        <div class="link-container">
            <div id="generated-link" class="generated-link"></div>
            <div class="copy-see-group">
                <button id="copy-button" class="button copy-button" onclick="copyToClipboard()">Copy Link</button>
                <button id="see-button" class="button copy-button" style="display:none;">To See</button>
                <button id="push-button" class="button copy-button" style="display:none;">Push</button>
            </div>
        </div>

        <div class="help-text">
            <p>Hold the mouse to draw paths & click to add points</p>
        </div>
    </div>

    <script>


        function clearCanvas() {
            currentPath = [];
            allPaths = [];
            singlePoints = [];
            document.getElementById('generated-link').innerText = '';
            document.getElementById('generated-link').style.display = 'none';
            document.getElementById('copy-button').style.display = 'none';
            document.getElementById('see-button').style.display = 'none';
            document.getElementById('push-button').style.display = 'none';
            window.lastGeneratedURL = '';
        }

        function copyToClipboard() {
            const linkText = window.lastGeneratedURL || document.getElementById('generated-link').innerText;
            navigator.clipboard.writeText(linkText).then(() => {
                const copyButton = document.getElementById('copy-button');
                copyButton.textContent = 'Copied!';
                copyButton.classList.add('success');
                setTimeout(() => {
                    copyButton.textContent = 'Copy Link';
                    copyButton.classList.remove('success');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy link. Please copy manually.');
            });
        }

    </script>

</body>

</html>