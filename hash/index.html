<html>
<head>
    <title>Path Drawing Tool</title>
    <meta charset="utf-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.5/lib/p5.js" type="text/javascript"></script>
    <script>
        let currentPath = [];
        let allPaths = [];
        let singlePoints = [];
        let limitLenght = 2000;
        let mouseStart = false;
        let mouseEnd = false;
        let dotLimit = 40;
        let pathLimit = 30;
        let isCanvasTouch = false;
        let animationPhase = 0;
        let animationSpeed = 3; // æ¯å¸§ç§»åŠ¨3åƒç´ 
        let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        let maxScaleFactor = isMobile ? 10 : 3; // æ‰‹æœº10å€ï¼Œç”µè„‘3å€
        let snapDistanceFactor = isMobile ? 5 : 2; // æ‰‹æœº5åƒç´ ï¼Œç”µè„‘2åƒç´ 
        function setup() {
            const canvas = createCanvas(500, 500).parent('canvas-container');
            textSize(10);
            textAlign(LEFT, CENTER);
            noFill();
            strokeWeight(1);
            canvas.elt.addEventListener('touchmove', function (e) {
                e.preventDefault();
            }, { passive: false });
            document.addEventListener("touchmove", preventBehavior, {
                passive: false
            });
        }
        function preventBehavior(e) {
            e.preventDefault();
        }
        function draw() {
            background(220);
            strokeWeight(1);
            
            // Draw grid
            push();
            stroke(200);
            strokeWeight(0.5);
            const gridSize = 500/15; // 15x15 grid
            for(let x = gridSize; x < width; x += gridSize) {
                line(x, 0, x, height);
            }
            for(let y = gridSize; y < height; y += gridSize) {
                line(0, y, width, y);
            }
            pop();

            for (let i = 0; i < allPaths.length; i++) {
                drawPathWithLabels(allPaths[i], i);
            }

            // Draw stats box
            push();
            fill(0, 180); // é»‘è‰²ï¼Œ20%é€æ˜
            stroke(0, 51);
            rect(10, 10, 150, 50, 5); // åœ†è§’çŸ©å½¢
            
            fill(255);
            noStroke();
            textAlign(LEFT, TOP);
            textSize(12);
            text(`Paths: ${allPaths.length}`, 20, 20);
            text(`Points: ${singlePoints.length}`, 20, 40);
            textSize(10); // æ¢å¤é»˜è®¤å­—ä½“å¤§å°
            pop();

            for (let i = 0; i < singlePoints.length; i++) {
                let pt = singlePoints[i];
                noFill();
                stroke(50)
                ellipse(pt.x, pt.y, 12, 12);

                fill(0);
                ellipse(pt.x, pt.y, 5, 5);
                noStroke();
                fill(50);
                text(`Dot ${i + 1}`, pt.x + 8, pt.y);
                stroke(0);
            }
            if (mouseIsPressed) {
                currentPath.push(createVector(mouseX, mouseY));
                drawRawPoints(currentPath);
            }
        }
        function drawRawPoints(path) {
            if (path.length === 0) return;
            
            // è®¡ç®—æ€»è·ç¦»
            let totalDist = dist(path[0].x, path[0].y, mouseX, mouseY);
            if (totalDist > 0) {
                animationPhase = (animationPhase + animationSpeed / totalDist) % 1;
            }
            
            // æ£€æŸ¥ç»ˆç‚¹æ˜¯å¦æ¥è¿‘å…¶ä»–ç‚¹
            let isNearOther = false;
            let snapDistance = snapDistanceFactor; // ä½¿ç”¨è®¾å¤‡ç›¸åº”çš„æ£€æµ‹è·ç¦»
            let maxScale = maxScaleFactor; // ä½¿ç”¨è®¾å¤‡ç›¸åº”çš„æ”¾å¤§å€æ•°
            
            // æ£€æŸ¥æ‰€æœ‰ç‹¬ç«‹ç‚¹
            for (let pt of singlePoints) {
                let d = dist(mouseX, mouseY, pt.x, pt.y);
                if (d < snapDistance) {
                    isNearOther = true;
                    break;
                }
            }
            
            // æ£€æŸ¥æ‰€æœ‰è·¯å¾„çš„ç«¯ç‚¹
            if (!isNearOther) {
                for (let p of allPaths) {
                    if (p.length > 0) {
                        // æ£€æŸ¥è·¯å¾„çš„èµ·ç‚¹
                        let d1 = dist(mouseX, mouseY, p[0].x, p[0].y);
                        // æ£€æŸ¥è·¯å¾„çš„ç»ˆç‚¹
                        let d2 = dist(mouseX, mouseY, p[p.length-1].x, p[p.length-1].y);
                        if (d1 < snapDistance || d2 < snapDistance) {
                            isNearOther = true;
                            break;
                        }
                    }
                }
            }
            
            noFill();
            stroke(50);
            strokeWeight(1);
            
            // è®¡ç®—å½“å‰åŠ¨ç”»ç‚¹çš„ä½ç½®
            let currentX = lerp(path[0].x, mouseX, animationPhase);
            let currentY = lerp(path[0].y, mouseY, animationPhase);
            
            // ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹çš„åœ†åœˆ
            ellipse(path[0].x, path[0].y, 12, 12);
            
            // æ ¹æ®æ˜¯å¦æ¥è¿‘å…¶ä»–ç‚¹æ¥å†³å®šç»ˆç‚¹åœ†åœˆçš„å¤§å°
            let circleSize = isNearOther ? 12 * maxScale : 12;
            ellipse(mouseX, mouseY, circleSize, circleSize);

            fill(50);
            noStroke();
            ellipse(path[0].x, path[0].y, 5, 5);
            let innerCircleSize = isNearOther ? 5 * maxScale : 5;
            ellipse(mouseX, mouseY, innerCircleSize, innerCircleSize);

            if (mouseIsPressed) {
                stroke(150);
                noFill();
                strokeWeight(3);
                beginShape(POINTS);
                let d = dist(path[0].x, path[0].y, mouseX, mouseY);
                let numDots = d / 10;
                for (let i = 0; i <= numDots; i++) {
                    let x = lerp(path[0].x, mouseX, i / numDots);
                    let y = lerp(path[0].y, mouseY, i / numDots);
                    vertex(x, y);
                }
                endShape();

                push();
                stroke(50);
                strokeWeight(1);
                // ellipse(currentX, currentY, 8, 8);
                
                let angle = atan2(mouseY - path[0].y, mouseX - path[0].x);
                translate(currentX, currentY);
                rotate(angle);
                
                fill(50);
                noStroke();
                let arrowSize = 8;
                triangle(0, 0, -arrowSize, -arrowSize/2, -arrowSize, arrowSize/2);
                pop();
            }
        }
        function drawPathWithLabels(path, pathIndex) {
            stroke(0);
            noFill();
            beginShape();
            for (let i = 0; i < path.length; i++) {
                let pt = path[i];
                vertex(pt.x, pt.y);
            }
            endShape();

            // ç»˜åˆ¶ç®­å¤´
            for (let i = 0; i < path.length - 1; i++) {
                let pt = path[i];
                let nextPt = path[i + 1];
                let angle = atan2(nextPt.y - pt.y, nextPt.x - pt.x);
                let arrowSize = 8;
                let midX = (pt.x + nextPt.x) / 2;
                let midY = (pt.y + nextPt.y) / 2;
                
                push();
                translate(midX, midY);
                rotate(angle);
                fill(0);
                noStroke();
                triangle(0, 0, -arrowSize, -arrowSize/2, -arrowSize, arrowSize/2);
                pop();
            }

            for (let i = 0; i < path.length; i++) {
                let pt = path[i];
                fill(0);
                ellipse(pt.x, pt.y, 5, 5);
                noStroke();
                fill(50, 100, 200);
                // text(`P${pathIndex + 1}-${i}`, pt.x + 5, pt.y);
                stroke(0);
            }
            let labelPos = path[0];
            noStroke();
            fill(50);
            text(`Path ${pathIndex + 1}`, labelPos.x + 8, labelPos.y - 8);
            stroke(0);
        }
        function mouseReleased() {
            if (currentPath.length > 1) {
                let totalLength = calculatePathLength(currentPath);
                let totalAngle = calculateTotalAngle(currentPath);
                if (totalLength < 20) {
                    let pt = currentPath[0].copy();
                    if (pt.x >= 0 && pt.x <= 500 && pt.y >= 0 && pt.y <= 500) {
                        singlePoints.push(pt);
                        if (singlePoints.length > dotLimit) {
                            singlePoints.shift();
                        }
                        console.log(`æ·»åŠ ç‹¬ç«‹ç‚¹: (${pt.x.toFixed(1)}, ${pt.y.toFixed(1)})`);
                    } else {
                        console.log(`å¿½ç•¥ç”»å¸ƒèŒƒå›´å¤–çš„ç‚¹: (${pt.x.toFixed(1)}, ${pt.y.toFixed(1)})`);
                    }
                } else {
                    let minPoints = 2;
                    let dynamicMax = floor(map(totalLength, 20, 500, 4, 12));
                    let maxPoints = constrain(dynamicMax, minPoints, 12);
                    let lengthFactor = map(totalLength, 20, 500, 0, 1);
                    let angleFactor = map(totalAngle, 0, 720, 0, 1);
                    let blend = lengthFactor * 0.5 + angleFactor * 0.5;
                    let mappedCount = round(map(blend, 0, 1, minPoints, maxPoints));
                    let pointCount = constrain(mappedCount, minPoints, maxPoints);
                    let simplified = resamplePath(currentPath, pointCount);
                    allPaths.push(simplified);
                    if (allPaths.length > pathLimit) {
                        allPaths.shift();
                    }
                }
            }
            currentPath = [];
        }
        function calculatePathLength(path) {
            let total = 0;
            for (let i = 1; i < path.length; i++) {
                total += p5.Vector.dist(path[i], path[i - 1]);
            }
            return total;
        }
        function calculateTotalAngle(path) {
            let totalAngle = 0;
            for (let i = 1; i < path.length - 1; i++) {
                let v1 = p5.Vector.sub(path[i], path[i - 1]);
                let v2 = p5.Vector.sub(path[i + 1], path[i]);
                if (v1.mag() === 0 || v2.mag() === 0) continue; // å¿½ç•¥ç„¡æ•ˆå‘é‡
                let angle = degrees(v1.angleBetween(v2));
                if (!isNaN(angle)) {
                    totalAngle += abs(angle);
                }
            }
            return totalAngle;
        }
        function resamplePath(path, count) {
            let totalLength = 0;
            let distances = [];
            for (let i = 1; i < path.length; i++) {
                let d = p5.Vector.dist(path[i], path[i - 1]);
                distances.push(d);
                totalLength += d;
            }
            if (isAlmostStraight(path)) {
                return [path[0].copy(), path[path.length - 1].copy()];
            }
            let interval = totalLength / (count - 1);
            let newPath = [];
            let targetDist = 0;
            let accumulated = 0;
            for (let i = 1; i < path.length; i++) {
                let segStart = path[i - 1];
                let segEnd = path[i];
                let d = distances[i - 1];
                if (accumulated + d >= targetDist) {
                    let t = (targetDist - accumulated) / d;
                    let newPoint = p5.Vector.lerp(segStart, segEnd, t);
                    let xx = Number(newPoint.x.toFixed(2));
                    let yy = Number(newPoint.y.toFixed(2));
                    newPoint.x = map(xx, 0, 500, 0, 500);
                    newPoint.y = map(yy, 0, 500, 0, 500);
                    newPath.push(newPoint);
                    targetDist += interval;
                    i--;
                } else {
                    accumulated += d;
                }
                if (newPath.length === count) break;
            }
            if (newPath.length < count) {
                newPath.push(path[path.length - 1].copy());
            }
            return newPath;
        }
        function isAlmostStraight(path) {
            let totalLength = calculatePathLength(path);
            if (totalLength < limitLenght) return true; // â­ é•·åº¦çŸ­å°±ç›´æ¥è¦–ç‚ºç›´ç·š
            let totalAngle = calculateTotalAngle(path);
            return totalAngle < 20 && path.length >= 3;
        }
        function keyPressed() {
            if (keyCode === ENTER) {
                let hashPart;
                const result = generateURLFromData();
                if (result && result.url) {
                    const linkElement = document.getElementById('generated-link');
                    hashPart = result.url.substring(result.url.indexOf('#data_'));
                    linkElement.innerText = hashPart;
                    linkElement.style.display = 'block';
                    document.getElementById('copy-button').style.display = 'block';
                    const seeButton = document.getElementById('see-button');
                    seeButton.style.display = 'inline-block';
                    seeButton.onclick = function () {
                        const newResult = generateURLFromData();
                        if (newResult && newResult.url) {
                            const fixedUrl = newResult.url
                              .replace(/%3D/gi, '=')
                              .replace(/%2F/gi, '/')
                              .replace(/%2B/gi, '+');
                            window.open(fixedUrl, '_blank');
                        }
                    };
                }
            }
        }
        function generateSeed(len = 7) {
            let seed = '';
            seed = Math.floor(Math.random() * 10000000 + 10000000);
            return seed;
        }
        function generateURLFromData() {
            let compressedPaths = allPaths.map(compressPath);
            let compressedDots = [];
            if (singlePoints && singlePoints.length > 0) {
                const validSinglePoints = singlePoints.filter(p =>
                    p.x >= 0 && p.x <= width && p.y >= 0 && p.y <= height
                );
                if (validSinglePoints.length < singlePoints.length) {
                    console.log(`è¿‡æ»¤æ‰${singlePoints.length - validSinglePoints.length}ä¸ªç”»å¸ƒèŒƒå›´å¤–çš„ç‚¹`);
                }
                if (validSinglePoints.length > 0) {
                    compressedDots = validSinglePoints.map(p => [
                        Number(p.x.toFixed(1)),
                        Number(p.y.toFixed(1))
                    ]);
                    console.log(`å‹ç¼©äº†${compressedDots.length}ä¸ªç‹¬ç«‹ç‚¹`);
                } else {
                    console.log('æ²¡æœ‰æœ‰æ•ˆçš„ç‹¬ç«‹ç‚¹éœ€è¦å‹ç¼©');
                }
            } else {
                console.log('æ²¡æœ‰ç‹¬ç«‹ç‚¹éœ€è¦å‹ç¼©');
            }
            let data = {
                p: compressedPaths,
                d: compressedDots
            };
            try {
                const jsonStr = JSON.stringify(data);
                const base64Str = btoa(jsonStr);
                const base64Url = encodeURIComponent(base64Str);
                const binaryStr = compressToBinary(data);
                const binaryUrl = encodeURIComponent(binaryStr);
                let shortestStr = base64Url;
                let compressionMethod = "base64";
                if (binaryUrl.length < shortestStr.length) {
                    shortestStr = binaryUrl;
                    compressionMethod = "binary";
                }
                const seed = generateSeed(7);
                const hashPart = "#data_" + shortestStr + "&seed_" + seed;
                let baseUrl;
                if (window.location.hostname === "127.0.0.1" || window.location.hostname === "localhost") {
                    baseUrl = window.location.origin + "/";
                } else if (window.location.hostname === "polypaths.up.railway.app") {
                    baseUrl = "https://polypaths.up.railway.app/";
                } else {
                    baseUrl = "https://aluanwang.com/Polypaths2025/";
                }
                const completeURL = baseUrl + hashPart;
                const totalLength = completeURL.length;
                const charCount = completeURL.split('').length;
                console.log(`ğŸ”— ç¶²å€é•·åº¦ï¼š${totalLength} å­—å…ƒ (${charCount} å€‹å­—ç¬¦)`);
                console.log(`ğŸ“Š å£“ç¸®æ–¹å¼ï¼š${compressionMethod}`);
                console.log(`ğŸ“Š å£“ç¸®å‰JSONé•·åº¦ï¼š${jsonStr.length} å­—å…ƒ`);
                console.log(`ğŸ“Š å£“ç¸®å¾ŒURLåƒæ•¸é•·åº¦ï¼š${shortestStr.length} å­—å…ƒ`);
                console.log(`ğŸ“Š å£“ç¸®æ¯”ä¾‹ï¼š${Math.round((1 - shortestStr.length / jsonStr.length) * 100)}%`);
                if (totalLength > 2000) {
                    console.warn("âš ï¸ é€™å€‹ç¶²å€å¤ªé•·äº†ï¼æœ‰äº›ç€è¦½å™¨å¯èƒ½æœƒçˆ†ç‚¸ã€‚");
                    offerAlternatives();
                } else if (totalLength > 1500) {
                    console.warn("âš ï¸ ç¶²å€å·²åé•·ï¼Œè«‹ç¯€åˆ¶ä½ é‚£æ”¾é£›è‡ªæˆ‘çš„ç¹ªåœ–ç¿’æ…£ã€‚");
                } else {
                }
                console.log("ğŸ”— è«‹è¤‡è£½ä»¥ä¸‹ç¶²å€ï¼š\n" + completeURL);
                const linkElement = document.getElementById('generated-link');
                linkElement.innerText = completeURL
                  .replace(/%3D/gi, '=')
                  .replace(/%2F/gi, '/')
                  .replace(/%2B/gi, '+');
                linkElement.style.display = 'block';
                const copyButton = document.getElementById('copy-button');
                if (copyButton) copyButton.style.display = 'block';
                const seeButton = document.getElementById('see-button');
                const pushButton = document.getElementById('push-button');
                const host = window.location.hostname;
                if (seeButton) seeButton.style.display = 'none';
                if (pushButton) pushButton.style.display = 'none';
                if (host === 'localhost' || host === '127.0.0.1' || host.includes('aluanwang.com')) {
                    if (seeButton) {
                        seeButton.style.display = 'inline-block';
                        seeButton.onclick = function () {
                            const newResult = generateURLFromData();
                            if (newResult && newResult.url) {
                                const fixedUrl = newResult.url
                                  .replace(/%3D/gi, '=')
                                  .replace(/%2F/gi, '/')
                                  .replace(/%2B/gi, '+');
                                window.open(fixedUrl, '_blank');
                            }
                        };
                    }
                } else if (host === 'polypaths.up.railway.app') {
                    if (pushButton) {
                        pushButton.style.display = 'inline-block';
                        pushButton.onclick = function () {
                            const newResult = generateURLFromData();
                            if (newResult && newResult.url) {
                                const hash = newResult.url.split('#')[1]
                                    ? '#' + newResult.url.split('#')[1]
                                        .replace(/%3D/gi, '=')
                                        .replace(/%2F/gi, '/')
                                        .replace(/%2B/gi, '+')
                                    : '';
                                fetch('https://postbotanybackend.up.railway.app/trigger-new-url', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ hash: hash })
                                })
                                    .then(res => {
                                        if (!res.ok) throw new Error(res.statusText);
                                        pushButton.textContent = 'success';
                                        pushButton.classList.add('success');
                                        pushButton.classList.remove('failed');
                                        setTimeout(() => {
                                            pushButton.textContent = 'Push';
                                            pushButton.classList.remove('success');
                                            pushButton.classList.remove('failed');
                                        }, 3000);
                                    })
                                    .catch(err => {
                                        pushButton.textContent = 'failed';
                                        pushButton.classList.add('failed');
                                        pushButton.classList.remove('success');
                                        setTimeout(() => {
                                            pushButton.textContent = 'Push';
                                            pushButton.classList.remove('failed');
                                            pushButton.classList.remove('success');
                                        }, 3000);
                                    });
                            }
                        };
                    }
                }
                return { url: completeURL, hash: hashPart, baseUrl, seed };
            } catch (err) {
                console.error(err);
                return null;
            }
        }
        function compressPath(path) {
            if (path.length < 2) return [];
            let startX = Math.round(path[0].x);
            let startY = Math.round(path[0].y);
            let result = [[startX, startY]];
            console.log(`å‹ç¼©è·¯å¾„: ç¬¬ä¸€ç‚¹åæ ‡ (${path[0].x}, ${path[0].y}) => (${result[0][0]}, ${result[0][1]})`);
            if (path.length === 2) {
                const endX = Math.round(path[1].x);
                const endY = Math.round(path[1].y);
                const dx = endX - startX;
                const dy = endY - startY;
                if (Math.abs(dx) > 127 || Math.abs(dy) > 127) {
                    console.log(`æ£€æµ‹åˆ°é•¿ç›´çº¿: èµ·ç‚¹(${startX}, ${startY})ï¼Œç»ˆç‚¹(${endX}, ${endY})ï¼Œåç§»(${dx}, ${dy})`);
                    const segments = Math.max(
                        Math.ceil(Math.abs(dx) / 120), // ç”¨120è€Œä¸æ˜¯127ï¼Œç•™ä¸€äº›ä½™é‡
                        Math.ceil(Math.abs(dy) / 120)
                    );
                    console.log(`å°†ç›´çº¿åˆ†ä¸º${segments}æ®µ`);
                    for (let i = 1; i <= segments; i++) {
                        const t = i / segments;
                        const midX = Math.round(startX + dx * t);
                        const midY = Math.round(startY + dy * t);
                        const prevX = i === 1 ? startX : Math.round(startX + dx * ((i - 1) / segments));
                        const prevY = i === 1 ? startY : Math.round(startY + dy * ((i - 1) / segments));
                        const segDx = midX - prevX;
                        const segDy = midY - prevY;
                        result.push([segDx, segDy]);
                        console.log(`åˆ†æ®µ${i}: æ·»åŠ ç‚¹(${midX}, ${midY})ï¼Œç›¸å¯¹åç§»(${segDx}, ${segDy})`);
                    }
                    return result;
                }
            }
            for (let i = 1; i < path.length; i++) {
                let dx = Math.round(path[i].x - path[i - 1].x);
                let dy = Math.round(path[i].y - path[i - 1].y);
                if (dx < -127) dx = -127;
                if (dx > 127) dx = 127;
                if (dy < -127) dy = -127;
                if (dy > 127) dy = 127;
                result.push([dx, dy]);
                console.log(`ç¬¬${i + 1}ç‚¹: åŸåæ ‡(${path[i].x}, ${path[i].y}) => ç›¸å¯¹åç§»(${dx}, ${dy})`);
            }
            return result;
        }
        function compressToBinary(data) {
            let result = '';
            result += String.fromCharCode(data.p.length);
            console.log(`ç¼–ç è·¯å¾„æ•°é‡: ${data.p.length}`);
            for (let path of data.p) {
                result += String.fromCharCode(path.length);
                console.log(`ç¼–ç è·¯å¾„ç‚¹æ•°é‡: ${path.length}`);
                for (let i = 0; i < path.length; i++) {
                    const point = path[i];
                    if (i === 0) {
                        const x = Math.min(255, Math.max(0, Math.round(point[0] / 2)));
                        const y = Math.min(255, Math.max(0, Math.round(point[1] / 2)));
                        result += String.fromCharCode(x) + String.fromCharCode(y);
                        console.log(`äºŒè¿›åˆ¶å‹ç¼©ï¼šåŸå§‹åæ ‡(${point[0]}, ${point[1]}) => ç¼–ç å€¼(${x}, ${y}) => è§£ç å(${x * 2}, ${y * 2})`);
                    } else {
                        let dx = point[0];
                        let dy = point[1];
                        const dxEncoded = (dx + 128) & 0xFF;
                        const dyEncoded = (dy + 128) & 0xFF;
                        result += String.fromCharCode(dxEncoded) + String.fromCharCode(dyEncoded);
                        console.log(`ç›¸å¯¹åæ ‡: (${point[0]}, ${point[1]}) => ç¼–ç å€¼(${dxEncoded}, ${dyEncoded}) => è§£ç å(${dxEncoded - 128}, ${dyEncoded - 128})`);
                    }
                }
            }
            const dotCount = data.d.length;
            result += String.fromCharCode(dotCount);
            console.log(`ç¼–ç ç‹¬ç«‹ç‚¹æ•°é‡: ${dotCount}`);
            if (dotCount > 0) {
                console.log(`å¼€å§‹ç¼–ç ${dotCount}ä¸ªç‹¬ç«‹ç‚¹`);
                for (let dot of data.d) {
                    const x = Math.min(255, Math.max(0, Math.round(dot[0] / 2)));
                    const y = Math.min(255, Math.max(0, Math.round(dot[1] / 2)));
                    result += String.fromCharCode(x) + String.fromCharCode(y);
                    console.log(`ç¼–ç ç‹¬ç«‹ç‚¹: åŸåæ ‡(${dot[0]}, ${dot[1]}) => ç¼–ç å€¼(${x}, ${y})`);
                }
            }
            console.log(`äºŒè¿›åˆ¶å‹ç¼©æ€»é•¿åº¦: ${result.length} å­—ç¬¦`);
            return btoa(result);
        }
        function offerAlternatives() {
            console.log("ğŸ”„ æ‚¨å¯ä»¥ï¼š");
            console.log("1. å‡å°‘è·¯å¾„æ•°é‡æˆ–è·¯å¾„ç‚¹æ•°é‡");
            console.log("2. å°è¯•ä½¿ç”¨æ›´ç®€å•çš„ç»˜å›¾");
            console.log("3. ä½¿ç”¨äº‘ç«¯å­˜å‚¨ (å¦‚ Imgurã€Gist ç­‰)");
        }
        function arrayToBase64(array) {
            let binary = '';
            const len = array.length;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(array[i]);
            }
            return btoa(binary);
        }
        function touchStarted() {
            if (currentPath.length === 0) {
                currentPath.push(createVector(mouseX, mouseY));
            }
            return true; // å…è¨±äº‹ä»¶å†’æ³¡ï¼Œè®“ä¸‹æ–¹æŒ‰éˆ•å¯é»æ“Š
        }
        function touchEnded() {
            if (currentPath.length > 1) {
                let totalLength = calculatePathLength(currentPath);
                let totalAngle = calculateTotalAngle(currentPath);
                if (totalLength < 20) {
                    let pt = currentPath[0].copy();
                    if (pt.x >= 0 && pt.x <= 500 && pt.y >= 0 && pt.y <= 500) {
                        singlePoints.push(pt);
                        if (singlePoints.length > 40) {
                            singlePoints.shift();
                        }
                        console.log(`æ·»åŠ ç¨ç«‹é»: (${pt.x.toFixed(1)}, ${pt.y.toFixed(1)})`);
                    } else {
                        console.log(`å¿½ç•¥ç•«å¸ƒç¯„åœå¤–çš„é»: (${pt.x.toFixed(1)}, ${pt.y.toFixed(1)})`);
                    }
                } else {
                    let minPoints = 2;
                    let dynamicMax = floor(map(totalLength, 20, 500, 4, 12));
                    let maxPoints = constrain(dynamicMax, minPoints, 12);
                    let lengthFactor = map(totalLength, 20, 500, 0, 1);
                    let angleFactor = map(totalAngle, 0, 720, 0, 1);
                    let blend = lengthFactor * 0.5 + angleFactor * 0.5;
                    let mappedCount = round(map(blend, 0, 1, minPoints, maxPoints));
                    let pointCount = constrain(mappedCount, minPoints, maxPoints);
                    let simplified = resamplePath(currentPath, pointCount);
                    allPaths.push(simplified);
                    if (allPaths.length > 30) {
                        allPaths.shift();
                    }
                }
            }
            currentPath = [];
            return true; // å…è¨±äº‹ä»¶å†’æ³¡ï¼Œè®“ä¸‹æ–¹æŒ‰éˆ•å¯é»æ“Š
        }
    </script>
 
</head>
<body>
    <div id="canvas-container"></div>
    <div class="container">
        <h2>Polypaths Drawing Mode</h3>
        <div class="button-container">
            <button class="button" onclick="generateURLFromData()">Generate Data</button>
            <button class="button" onclick="clearCanvas()">Clear</button>
        </div>
        <div class="link-container">
            <div id="generated-link" class="generated-link"></div>
            <div class="copy-see-group">
                <button id="copy-button" class="button copy-button" onclick="copyToClipboard()">Copy Link</button>
                <button id="see-button" class="button copy-button" style="display:none;">To See</button>
                <button id="push-button" class="button copy-button" style="display:none;">Push</button>
            </div>
        </div>
        <div class="help-text">
            <p>Hold the mouse to draw paths & click to add points</p>
        </div>
    </div>
    <script>
        function clearCanvas() {
            currentPath = [];
            allPaths = [];
            singlePoints = [];
            document.getElementById('generated-link').innerText = '';
            document.getElementById('generated-link').style.display = 'none';
            document.getElementById('copy-button').style.display = 'none';
            document.getElementById('see-button').style.display = 'none';
            document.getElementById('push-button').style.display = 'none';
            window.lastGeneratedURL = '';
        }
        function copyToClipboard() {
            const linkText = window.lastGeneratedURL || document.getElementById('generated-link').innerText;
            navigator.clipboard.writeText(linkText).then(() => {
                const copyButton = document.getElementById('copy-button');
                copyButton.textContent = 'Copied!';
                copyButton.classList.add('success');
                setTimeout(() => {
                    copyButton.textContent = 'Copy Link';
                    copyButton.classList.remove('success');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy link. Please copy manually.');
            });
        }
    </script>
</body>
</html>